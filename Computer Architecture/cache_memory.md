# Cache Memory

* 속도가 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다.

* CPU가 주기억장치에서 저장된 데이터를 읽어올 떄, 자주 사용하는 데이터를 캐시메모리에 저장, 그 이후 같은 메모리 사용 시, 캐시메모리에서 먼저 가져온다.

* 빠른 대신, 용량이 적고 비싸다(하드디스크 1TB는 4만원, SSD는 40만원, 캐시메모리 4GB는 약 4000만원)



### 듀얼코어 이상의 프로세서의 캐시 메모리

* 각 코어마다 독립된 L1캐시 메모리를 가지고, 두 코어가 공유하는 L2캐시 메모리가 내장됨
* L1캐시의 절반은 명령어를 처리하기 직전의 명령어를 임시 저장, 나머지 절반에는 실행 후 명령어를 임시 저장
  * L1 : CPU 내부에 존재
  * L2 : CPU와 RAM 사이에 존재
  * L3 : 보통 메인보드에 존재



### 캐시 메모리의 작동 원리

##### 시간 지역성

* for나 while 같은 반복문에 사용하는 조건 변수처럼 한번 참조된 데이터는 잠시 후 또 참조될 가능성이 높음



##### 공간 지역성

* A[0],A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시후 또 사용될 가능성이 높음 
* ex) 행렬곱에서 전치행렬 사용



캐시에 데이터를 저장 시, 공간 지역성을 활용하기 위해 주변 데이터도 같이 가져와 대비하게된다.

캐시에 CPU가 요청한 데이터가 있을경우 Cache Hit, 없어서 DRAM에서 가져오게 된다면 Cache Miss가 된다.



### 캐시 미스의 예시

* Cold miss : 해당 메모리 주소를 처음 불러서 생기는 미스

* Conflict miss : 동일한 캐시 메모리 주소에 다른값이 할당되어 있을 경우에 생기는 미스
* Capacity miss : 캐시 메모리의 공간이 부족해서 생기는 미스, Conflict와 비슷하게 볼 수 있지만 Conflict는 할당문제, Capacity는 공간문제이다.



Conflict miss와 Capacity miss 같은 경우는 크기가 커지면 문제가 생길 가능성이 줄어들지만, 동시에 접근속도가 느려지고 파워를 많이 잡아먹게 된다.



### 구조 및 작동 방식

##### Direct Mapped Cache

가장 기본적인 구조, DRAM의 여러 주소가 캐시메모리의 한 주소에 대응되는 방식

캐시메모리의 공간이 8개 `(000~111)이고 메모리 공간이 32개(00000~11111)인 경우`를 예시로 설명

메인메모리 공간의 주소 뒤 3자리를 가지고 캐시메모리에 할당, 이 때, 세자리 000이 인덱스 필드 인덱스 필드를 제외한 앞 두자리를 태그필드라고 함

간단하고 빠르지만 Conflict Miss가 인덱스필드가 같은 데이터들을 자주 활용하는 경우에 발생하는 단점이 있다.  

##### Fully Associative Cache

비어있는 메모리에 마음대로 저장하는 방식

캐시 안에 저장할 떄는 매우 간단하지만, 찾을 때 오래걸린다.

조건이나 규칙이 없기 때문에, 특정 캐시 Set 안에 있는 모든 블럭을 한번에 찾아서 원하는 데이터가 있는지 검색해야하며, 이를 위한 CAM이라는 특수한 메모리 구조를 사용해야한다. 당연히 매우 비싸다.

#### Set Associative Cache

Direct와 Fully를 섞은 방식. 특정행을 지정하고, 그 행안의 어떤 열이든 비어있을 때 저장하는 방식.

Direct에 비해서 탐색은 느리지만 저장이 빠르고 Fully보다 탐색이 빠르고 저장이 느리다.



### Cache메모리 히트율 기준 속도 계산

캐시메모리 히트 확률 : R

캐시메모리 속도 : C

일반메모리 속도 : M
$$
C+ (1-R) \times M
$$
 
