# CPU 스케줄러

## CPU 스케줄러란?

다중 프로그래밍을 가능하게 하기 위한 운영체제의 동작 기법

어떤 프로세스에 cpu를 배정할 지 결정

모든 프로세스가 공평하게 작업할 수 있도록 하기 위해 사용<br><br><br>

## CPU 스케줄러의 종류

![Untitled](https://user-images.githubusercontent.com/52027965/166668204-38d9d615-42d4-4ecf-8c0f-46e8126de45b.png)

1. 장기 스케줄러
    
    메모리에 올라가 있는 프로세스의 수를 제어
    
    시스템의 과부하를 막기 위해 어떤 작업을 받아들일지 결정
    
2. 단기 스케줄러
    
    프로세스에 cpu를 할당
    
3. 중기 스케줄러
    
    cpu를 사용하려는 프로세스 간 중재하여 일시 보류 & 재활성화 담당
    
    단기 스케줄링이 원만히 이루어지도록 완충하는 역할
    <br><br><br>

## CPU 스케줄링 목적

1. 공평성
    
    모든 프로세스가 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제돼선 안 된다
    
2. 효율성
    
    시스템 자원을 놀리는 시간 없이 스케줄링해야 한다
    
3. 안정성
    
    우선순위를 사용하여 중요한 프로세스가 먼저 처리되도록 해야 한다
    
4. 반응 시간 보장
    
    응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다
    
5. 무한 연기 방지
    
    특정 프로세스의 작업이 무한히 연기되어서는 안 된다
    
6. CPU 사용율을 늘림
    
    가능하면 많은 일을 수행한다
    
7. 기아 현상을 낮춤
    
    특정 프로세스의 작업이 무한히 연기돼선 안 된다
    
    +) 기아현상이란?
    
    우선 순위로 작업을 처리할 때 우선순위가 낮은 작업은 영원히 처리되지 않는 문제
    <br><br><br>

## 비선점형과 선점형

- 비선점형 스케줄링
    
    ![Untitled 1](https://user-images.githubusercontent.com/52027965/166668193-12f47c01-6aff-4c85-a044-c571653a0885.png)
    
    - 프로세스가 스스로 반납할 때까지 CPU를 뺏기지 않음
    - time-slice가 없는 스케줄링
    - 프로세스가 스스로 CPU를 놓아주는 시점(작업이 완료되는 시점)에 사용한다<br><br>
    
- 선점형 스케줄링
    
    ![Untitled 2](https://user-images.githubusercontent.com/52027965/166668199-933b3dfe-d943-432b-a896-9382425af905.png)
    
    - 실행 도중 다른 프로세스에게 CPU를 뺏길 수 있음
    - 낮은 우선순위를 가진 프로세스보다 높은 우선순위를 가진 프로세스가 CPU를 선점하는 방식
    - 우선순위가 높은 프로세스를 빠르게 처리해야할 때 유용
    - 선점이 일어날 경우, 오버헤드가 발생하고 처리시간 예측이 힘들다
<br><br><br>

## 스케줄링 알고리즘

![Untitled 3](https://user-images.githubusercontent.com/52027965/166668200-b6570a2f-f85c-45bd-a6d8-62d00c2912a8.png)

- 비선점 스케줄링
    1. 우선순위 스케줄링
        - 프로세스마다 우선순위를 붙여 우선순위가 높은 프로세스를 먼저 실행하는 방식
        - 우선순위가 동일한 프로세스는 FIFO 순서로 스케줄링함
        - 단점 : 우선순위가 낮은 프로세스는 무한정 연기돼 기아현상이 발생<br><br>
        
    2. 기한부 스케줄링
        - 프로세스에 일정한 시간을 제공하고 그 시간안에 프로세스를 완료하도록 하는 기법. 일정시간동안 프로세스가 완료되지 않으면 삭제하고 다시 실행한다.
        - 단점 : 주어진 시간 내에 완료되지 못했을 때 제거되거나 처음부터 다시 실행되기 때문에 손해 발생한다. 작업 시간이나 상황 등 정보를 미리 예측하기 어렵다.<br><br>
    
    1. FCFS 스케줄링(First Come First Served**)**
        - 선입선출 방식, 준비 큐에 도착한 순서대로 CPU를 할당
        - 모든 프로세스의 우선순위가 동일하고, 프로세스의 CPU 처리 시간을 따로 고려하지 않기 때문에 매우 단순하고 공평한 방법이다.
        - 단점 : CPU 처리 시간이 긴 프로세스가 앞에 올 경우 뒤의 프로세스가 한없이 기다려야 하기 때문에 비효율적이게 된다.<br><br>
        
    2. SJF 스케줄링(Shortest Job First)
        - 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당
        - 늦게 도착하더라도 CPU 처리 시간이 앞에 대기중인 프로세스보다 짧으면 먼저 CPU를 할당받을 수 있다.
        - 단, 비선점형 방식이기 때문에 CPU를 사용중인 프로세스보다 처리 시간이 짧더라도 빼앗지는 못한다.
        - 단점 : 기아 현상이 발생한다. 처리 시간이 긴 프로세스의 경우 처리 시간이 짧은 프로세스가 계속해서 들어온다면 대기 큐에서 영영 CPU를 할당받지 못할 수 있다.<br><br>
        
    3. HRN 스케줄링(Highest response ratio next)
        - 수행시간의 길이와 대기 시간을 모두 고려해 우선순위를 정한다.
        - SJF 스케줄링에 Aging 기법을 합친 비선점형 알고리즘이다.
        - Aging이란 나이를 먹는다는 의미 그대로 starvation을 해결하기 위해 대기 시간이 길어지면 우선순위를 높여주는 방법이다.
        - SJF와 마찬가지로 실행 시간이 적은 프로세스의 우선 순위가 높지만 대기 시간이 너무 길어지면 실행 시간이 길더라도 CPU를 할당받을 수 있다. 하지만 여전히 공평성이 말끔히 해결되지는 않는다.
        <br><br><br><br>
        
- 선점 스케줄링
    1. RR 스케줄링
        - 각 프로세스는 같은 크기의 CPU 시간을 할당 받고 선입선출에 의해 실행된다.
        - 할당시간이 너무 크면 선입선출과 다를 바가 없어지고, 너무 작으면 오버헤드가 너무 커진다.
    <br><br>
    1. SRTF 스케줄링(Shortest Remaining Time First)
        - 먼저 온 프로세스가 CPU를 할당받고 있더라도 남은 처리 시간이 뒤에 온 프로세스의 처리 시간보다 길면 CPU를 빼앗김
        - 장점 : 어떤 알고리즘보다 평균 대기 시간이 짧다
        - 단점 : 선점형 방식이기 떄문에 문맥교환이 잦아 오버헤드가 커진다. 기아현상이 심각하게 발생할 수 있다. CPU의 예상 시간을 예측하기가 힘들기 때문에 실제로 사용되기 어렵다
        <br><br>
    2. 다단계 큐 스케줄링
        
        ![Untitled 4](https://user-images.githubusercontent.com/52027965/166668201-2da05c49-8278-445b-8a0a-9ee9678a7d12.png)
        
        - 우선순위에 따라 준비 큐를 여러 개 사용하는 방식
        - 우선순위가 높은 큐에 먼저 CPU가 할당되어 큐에 속한 모든 프로세스가 처리되야 다음 우선순위 큐가 실행될 수 있다. 그리고 한 번 우선순위가 매겨저 준비 큐에 들어가면 이 우선순위는 바뀌지 않는다.
        - 각 큐는 독립적인 스케줄링 알고리즘을 가질 수 있는데, 보통 전면 프로세스들이 속해있는 큐는 우선순위고 높고 라운드 로빈 스케줄링을 사용해 타임 슬라이스를 작게한다.
        - 후면 프로세스에는 사용자와의 상호작용이 없으므로 가장 간단한 FCFS 방식으로 처리한다. 보통 총 CPU 시간이 전면 프로세스의 처리에 80%, 후면 프로세스 처리에 20%가 할당된다.
        - 단점 : 기아현상과 공평성 문제
        <br><br>
    3. 다단계 피드백 큐 스케줄링
        
        ![Untitled 5](https://user-images.githubusercontent.com/52027965/166668202-c2ff9ff8-8723-4430-a680-c2a9c7a62430.png)
        
        - 다단계 큐의 공평성 문제를 완화하기 위해 우선순위 하락이 가능한 알고리즘이다. 우선순위가 변동되기 때문에 큐 사이의 이동이 가능하다.
        - 한 번 CPU를 할당받은 프로세스는 우선순위가 조금 낮아진다. 따라서 더 낮은 큐로 이동하게 된다. (우선순위가 높아져 상위 큐로 이동할 수도 있다)
        - 그리고 더 보완하기 위해 우선순위가 높은 큐보다 우선순위가 낮은 큐에 타임 슬라이스 크기를 크게 준다. 어렵게 얻은 CPU를 좀 더 오랫동안 사용하게 해주기 위함이다.
<br><br><br>
## Reference

### CPU 스케줄러의 종류

[https://velog.io/@ss-won/OS-CPU-Scheduler와-Dispatcher](https://velog.io/@ss-won/OS-CPU-Scheduler%EC%99%80-Dispatcher)

[https://jhnyang.tistory.com/372](https://jhnyang.tistory.com/372)

[https://velog.io/@jeongpar/CPU-스케줄링](https://velog.io/@jeongpar/CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)

### CPU 스케줄링 알고리즘

[https://hyunah030.tistory.com/4](https://hyunah030.tistory.com/4)