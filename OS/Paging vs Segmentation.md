# 메모리 할당
![image](https://user-images.githubusercontent.com/52027965/177439190-02c32e13-bf31-4bdf-bb39-b13a83d6a919.png)<br>
메모리는 일반적으로 두 영역으로 나뉜다
- OS 상주 영역 : 인터럽트 벡터와 함께 낮은 주소 영역 사용
- 사용자 프로세스 영역 : 높은 주소 영역 사용

<br><br>

## 메모리 할당 방법론 목적
멀티프로그래밍 환경에서 한정된 메모리 공간을 최대한 효율적으로 사용하기 위함

<br><br>

## 연속 할당
각 프로세스가 메모리의 연속적인 공간에 적재

<br>

### 고정분할
![image](https://user-images.githubusercontent.com/52027965/177439889-bd94f62a-58f3-4fad-a8f9-d6642cc7e7d4.png)
- 물리적 메모리를 몇 개의 영구적 분할로 나눔
- 하나의 분할에 하나의 프로그램을 적재
- 내/외부 조각 발생
  - 외부조각
    - 분할의 크기 < 프로그램의 크기
    - 아무 프로그램도 배정되지 않은 빈 공간이지만 프로그램이 올라갈 수 없음
  - 내부조각
    - 분할의 크기 > 프로그램의 크기, 
    - 분할에 프로그램이 배정됐지만 남는 부분이 존재함

<br>

### 가변분할
![image](https://user-images.githubusercontent.com/52027965/177440717-783d5d2c-6125-448f-85c8-b71ee9f8dc91.png)
- 프로그램의 크기를 고려해서 할당
- 분할의 크기, 개수가 동적으로 변함
- 외부 조각 발생

<br><br>

## 불연속 할당
하나의 프로세스가 물리적 메모리의 여러 위치에 분산돼 올라감

<br>

### 페이징 기법
![image](https://user-images.githubusercontent.com/52027965/177443470-db3533c5-13f0-41ca-bd67-7bcfff4fdf72.png)
- 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장
- 페이지 테이블을 이용해 논리 주소를 물리 주소로 변환
- 페이지 테이블은 메인메모리에 상주
- 내부 단편화 발생
- CPU가 프로세스의 가상중소를 실행하기 위해 접근하면 MMU가 물리 주소로 변환해 해당 데이터를 CPU에게 가져다줌
![image](https://user-images.githubusercontent.com/52027965/177493088-c9a16301-a1f6-4239-96ea-21d330d1dc0f.png)

<br>

### 세그멘테이션
![image](https://user-images.githubusercontent.com/52027965/177476157-d00c13e8-6432-4326-8d36-a4c294d1bbc7.png)
![image](https://user-images.githubusercontent.com/52027965/177472251-357a412d-85c2-47f3-b5af-d7313e8c4ecb.png)
- 프로세스를 스택, 데이터, 코드, 힙 등의 의미 단위로 나누어 올림
- 논리적 주소가 <세그먼트 번호, 오프셋>으로 나뉘어 사용
  - 세그먼트 번호는 세그먼트 테이블의 인덱스로 사용
  - 오프셋은 0과 세그먼트 경계값 사이
- 세그먼트 테이블은 각 세그먼트의 경계와 세그먼트 기준을 가지고 세그먼트 메모리 주소의 시작과 끝을 나타냄
- 세그먼트는 의미 단위이기 때문에 공유와 보호에 있어 페이징보다 효과적
- 세그먼트의 길이가 동일하지 않아 외부 조각 발생

<br>

### 페이지드 세그멘테이션
- 프로세스를 나눌 때 세그먼트 단위로 나눔
- 물리적 메모리에 적재하는 단위를 페이지 단위로
- 하나의 세그먼트 크기를 페이지 크기의 배수가 되도록 함
- 보호와 공유가 용이하고 외부 단편화를 없앰
- 세그먼트 테이블과 페이지 테이블이 필요해져 주소 변환과정이 더 복합해지고 시간이 오래 걸림